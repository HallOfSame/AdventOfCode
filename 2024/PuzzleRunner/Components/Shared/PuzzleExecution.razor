@using Helpers.Drawing
@using Helpers.Interfaces
<div>
    <MudExpansionPanels MultiExpansion="true">
        <MudExpansionPanel Text="Actions" Expanded="true">
            @if (stepExecutionPuzzle is not null)
            {
                <MudToolBar>
                    <MudSelect Dense Variant="Variant.Outlined" Label="Part to execute" T="int" Value="puzzlePartToExecute" ValueChanged="newVal => OnPartToExecuteChange(newVal)">
                        <MudSelectItem Value="1">One</MudSelectItem>
                        <MudSelectItem Value="2">Two</MudSelectItem>
                    </MudSelect>
                    <MudButton OnClick="ResetPuzzle" Color="Color.Error" StartIcon="@Icons.Material.Filled.RestartAlt">Reset</MudButton>
                    <MudButton Disabled="DisablePrevStep" OnClick="PrevStep" StartIcon="@Icons.Material.Filled.ArrowBack">Prev</MudButton>
                    <MudButton OnClick="NextStep" EndIcon="@Icons.Material.Filled.ArrowForward">Next</MudButton>
                </MudToolBar>
            }
            else
            {
                <div style="display: flex; gap: 16px;">
                    <MudButton OnClick="ExecutePartOne">Part One</MudButton>
                    <MudButton OnClick="ExecutePartTwo">Part Two</MudButton>
                </div>
            }
        </MudExpansionPanel>
        <MudExpansionPanel Text="Results" Expanded="true">
            @if (currentResult is null)
            {
                <span>Waiting for run</span>
            }
            else if (executionActive)
            {
                <MudProgressCircular Indeterminate="true" />
            }
            else
            {
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    @if (currentResult.Exception is null)
                    {
                        <div style="display: flex; align-items: center">
                            <MudChip T="string" Color="Color.Success">Success</MudChip> <span>Result: @currentResult.Result</span><MudIconButton OnClick="CopyResultToClipboard" Icon="@Icons.Material.Filled.CopyAll" />
                        </div>
                    }
                    else
                    {
                        <div style="display: flex; align-items: center">
                            <MudChip T="string" Color="Color.Error">Exception</MudChip> <span>Exception: @currentResult.Exception.ToString()</span>
                        </div>
                    }

                    <span>Elapsed Time: @FormatElapsedTime()</span>
                </div>
            }
        </MudExpansionPanel>

        @if (visualizer is not null)
        {
            <MudExpansionPanel Text="Visualization" Expanded="true">
                <BlazorCanvas CoordinatesToDraw="currentVisual"/>
            </MudExpansionPanel>
        }
    </MudExpansionPanels>
</div>

@inject IJSRuntime JsRuntime
@code {
    [Parameter]
    [EditorRequired]
    public IPuzzle Puzzle { get; set; } = null!;

    private IStepExecutionPuzzle? stepExecutionPuzzle;
    private ISingleExecutionPuzzle? singleExecutionPuzzle;
    private IVisualize2d? visualizer;
    private ExecutionResult? currentResult;
    private bool executionActive;
    private DrawableCoordinate[] currentVisual = [];
    private int puzzlePartToExecute = 1;
    private object? prevState;

    private bool DisablePrevStep => prevState is null;

    protected override void OnInitialized()
    {
        stepExecutionPuzzle = Puzzle as IStepExecutionPuzzle;
        singleExecutionPuzzle = Puzzle as ISingleExecutionPuzzle;
        // ReSharper disable once SuspiciousTypeConversion.Global
        visualizer = Puzzle as IVisualize2d;

        base.OnInitialized();
    }

    private async Task ResetPuzzle()
    {
        await Execution(stepExecutionPuzzle!.ResetToInitialState);
    }

    private async Task NextStep()
    {
        if (puzzlePartToExecute == 1)
        {
            await Execution(async () => currentResult = await stepExecutionPuzzle!.ExecuteStepPartOne());
        }
        else
        {
            await Execution(async () => currentResult = await stepExecutionPuzzle!.ExecuteStepPartTwo());
        }

        prevState = ((StepExecutionResult)currentResult!).CurrentState;
    }

    private async Task PrevStep()
    {
        await Execution(async () => await stepExecutionPuzzle!.RevertState(prevState!));
    }

    private async Task ExecutePartOne()
    {
        await Execution(async () => currentResult = await singleExecutionPuzzle!.ExecutePartOne());
    }

    private async Task ExecutePartTwo()
    {
        await Execution(async () => currentResult = await singleExecutionPuzzle!.ExecutePartTwo());
    }

    private async Task Execution(Func<Task> executeMethod)
    {
        executionActive = true;
        // Let ui update
        await Task.Yield();
        await executeMethod();
        executionActive = false;
        UpdateVisual();
    }

    private void UpdateVisual()
    {
        if (executionActive || visualizer is null)
        {
            return;
        }

        currentVisual = visualizer.GetCoordinates();
    }

    private async Task OnPartToExecuteChange(int newValue)
    {
        puzzlePartToExecute = newValue;
        // Make sure we don't have a corrupt state that's partly part 1 and starts running part 2
        // This might not always be necessary
        // Some puzzles might actually rely on part 1 running first
        await stepExecutionPuzzle!.ResetToInitialState();
    }

    private async Task CopyResultToClipboard()
    {
        await JsRuntime.InvokeVoidAsync("copyTextToClipboard", currentResult!.Result!);
    }

    private string FormatElapsedTime()
    {
        // Format the output
        return $"{currentResult!.ElapsedTime.Minutes:D2}m {currentResult.ElapsedTime.Seconds:D2}s {currentResult.ElapsedTime.Milliseconds:D3}ms {currentResult.ElapsedTime.Microseconds:D9}us";
    }

}
